"""Diff service for generating and managing code diffs.

This module provides the DiffService for creating, saving, and managing
diffs generated from implementation plans. Currently uses stub implementation
that generates placeholder diffs.
"""

import json
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from pathlib import Path
from uuid import UUID, uuid4


class DiffStatus(str, Enum):
    """Status of a diff in the review workflow."""

    PENDING = "pending"
    """Diff is awaiting review."""

    APPROVED = "approved"
    """Diff has been approved for application."""

    REJECTED = "rejected"
    """Diff has been rejected."""

    APPLIED = "applied"
    """Diff has been applied to the codebase."""


@dataclass
class Diff:
    """Represents a code diff.

    Attributes:
        id: Unique identifier for the diff.
        target_file: Path to the file this diff applies to.
        content: The diff content in unified diff format.
        status: Current status of the diff.
        created_at: When the diff was created.
        plan_id: ID of the ImplementationPlan that generated this diff.
    """

    id: UUID
    target_file: str
    content: str
    status: DiffStatus
    created_at: datetime
    plan_id: UUID | None = None

    def to_dict(self) -> dict[str, str | None]:
        """Convert diff to dictionary for serialization."""
        return {
            "id": str(self.id),
            "target_file": self.target_file,
            "content": self.content,
            "status": self.status.value,
            "created_at": self.created_at.isoformat(),
            "plan_id": str(self.plan_id) if self.plan_id else None,
        }

    @classmethod
    def from_dict(cls, data: dict[str, str | None]) -> "Diff":
        """Create Diff from dictionary."""
        return cls(
            id=UUID(str(data["id"])),
            target_file=str(data["target_file"]),
            content=str(data["content"]),
            status=DiffStatus(str(data["status"])),
            created_at=datetime.fromisoformat(str(data["created_at"])),
            plan_id=UUID(str(data["plan_id"])) if data.get("plan_id") else None,
        )


@dataclass
class DiffResult:
    """Result of a diff operation.

    Attributes:
        diff: The generated diff.
        diff_path: Path where the diff was saved.
        is_empty: Whether the diff is empty (no changes).
    """

    diff: Diff
    diff_path: Path | None = None
    is_empty: bool = False


class DiffService:
    """Service for generating and managing code diffs.

    The DiffService handles the diff workflow:
    - Generating diffs from implementation plans (stub)
    - Saving diffs to the audit directory
    - Loading pending diffs for review
    - Approving/rejecting diffs
    - Tracking diff status

    Attributes:
        project_root: Root directory of the project.
        diffs_dir: Directory for storing diffs.
    """

    def __init__(self, project_root: Path) -> None:
        """Initialize the diff service.

        Args:
            project_root: Root directory of the project.
        """
        self._project_root = project_root
        self._diffs_dir = project_root / "audit" / "diffs"
        self._index_path = self._diffs_dir / "_index.json"

    @property
    def project_root(self) -> Path:
        """Get the project root directory."""
        return self._project_root

    @property
    def diffs_dir(self) -> Path:
        """Get the diffs directory."""
        return self._diffs_dir

    def generate_diff(
        self,
        target_file: str,
        plan_id: UUID | None = None,
    ) -> Diff:
        """Generate a diff for a target file.

        Currently returns a stub diff. Will be replaced with LLM-generated
        diffs in Milestone 04.

        Args:
            target_file: Path to the file to implement.
            plan_id: Optional ID of the ImplementationPlan.

        Returns:
            A Diff object with placeholder content.
        """
        # Stub implementation - generate placeholder diff
        timestamp = datetime.now()
        diff_content = self._generate_stub_diff(target_file)

        return Diff(
            id=uuid4(),
            target_file=target_file,
            content=diff_content,
            status=DiffStatus.PENDING,
            created_at=timestamp,
            plan_id=plan_id,
        )

    def _generate_stub_diff(self, target_file: str) -> str:
        """Generate a stub diff for development.

        Args:
            target_file: Path to the target file.

        Returns:
            Placeholder diff content.
        """
        return f"""--- a/{target_file}
+++ b/{target_file}
@@ -1,1 +1,5 @@
-# TODO: Implement this file
+# Implementation generated by rice-factor
+
+def main():
+    \"\"\"Main entry point.\"\"\"
+    pass
"""

    def save_diff(self, diff: Diff) -> Path:
        """Save a diff to the audit/diffs directory.

        Args:
            diff: The diff to save.

        Returns:
            Path to the saved diff file.
        """
        self._diffs_dir.mkdir(parents=True, exist_ok=True)

        # Create filename with timestamp
        timestamp_str = diff.created_at.strftime("%Y%m%d_%H%M%S")
        safe_filename = diff.target_file.replace("/", "_").replace("\\", "_")
        filename = f"{timestamp_str}_{safe_filename}.diff"
        diff_path = self._diffs_dir / filename

        # Save diff content
        diff_path.write_text(diff.content, encoding="utf-8")

        # Update index
        self._update_index(diff, diff_path)

        return diff_path

    def _update_index(self, diff: Diff, diff_path: Path) -> None:
        """Update the diff index file.

        Args:
            diff: The diff to add to the index.
            diff_path: Path where the diff was saved.
        """
        index = self._load_index()
        index[str(diff.id)] = {
            **diff.to_dict(),
            "path": str(diff_path.relative_to(self._diffs_dir)),
        }
        self._save_index(index)

    def _load_index(self) -> dict[str, dict[str, str | None]]:
        """Load the diff index."""
        if not self._index_path.exists():
            return {}
        content = self._index_path.read_text(encoding="utf-8")
        result = json.loads(content)
        if isinstance(result, dict):
            return result
        return {}

    def _save_index(self, index: dict[str, dict[str, str | None]]) -> None:
        """Save the diff index."""
        self._diffs_dir.mkdir(parents=True, exist_ok=True)
        self._index_path.write_text(
            json.dumps(index, indent=2),
            encoding="utf-8",
        )

    def load_pending_diff(self) -> Diff | None:
        """Load the most recent pending diff.

        Returns:
            The most recent pending diff, or None if none exist.
        """
        index = self._load_index()
        pending_diffs: list[Diff] = []

        for diff_data in index.values():
            if diff_data.get("status") == DiffStatus.PENDING.value:
                pending_diffs.append(Diff.from_dict(diff_data))

        if not pending_diffs:
            return None

        # Return most recent
        pending_diffs.sort(key=lambda d: d.created_at, reverse=True)
        return pending_diffs[0]

    def load_diff(self, diff_id: UUID) -> Diff | None:
        """Load a specific diff by ID.

        Args:
            diff_id: The diff ID to load.

        Returns:
            The diff, or None if not found.
        """
        index = self._load_index()
        diff_data = index.get(str(diff_id))
        if diff_data:
            return Diff.from_dict(diff_data)
        return None

    def approve_diff(self, diff_id: UUID) -> bool:
        """Approve a diff for application.

        Args:
            diff_id: The diff ID to approve.

        Returns:
            True if approved, False if not found.
        """
        return self._update_status(diff_id, DiffStatus.APPROVED)

    def reject_diff(self, diff_id: UUID) -> bool:
        """Reject a diff.

        Args:
            diff_id: The diff ID to reject.

        Returns:
            True if rejected, False if not found.
        """
        return self._update_status(diff_id, DiffStatus.REJECTED)

    def mark_applied(self, diff_id: UUID) -> bool:
        """Mark a diff as applied.

        Args:
            diff_id: The diff ID to mark as applied.

        Returns:
            True if marked, False if not found.
        """
        return self._update_status(diff_id, DiffStatus.APPLIED)

    def _update_status(self, diff_id: UUID, status: DiffStatus) -> bool:
        """Update the status of a diff.

        Args:
            diff_id: The diff ID to update.
            status: The new status.

        Returns:
            True if updated, False if not found.
        """
        index = self._load_index()
        diff_key = str(diff_id)

        if diff_key not in index:
            return False

        index[diff_key]["status"] = status.value
        self._save_index(index)
        return True

    def get_diff_status(self, diff_id: UUID) -> DiffStatus | None:
        """Get the status of a diff.

        Args:
            diff_id: The diff ID to check.

        Returns:
            The diff status, or None if not found.
        """
        diff = self.load_diff(diff_id)
        return diff.status if diff else None

    def load_approved_diff(self) -> Diff | None:
        """Load the most recent approved diff.

        Returns:
            The most recent approved diff, or None if none exist.
        """
        index = self._load_index()
        approved_diffs: list[Diff] = []

        for diff_data in index.values():
            if diff_data.get("status") == DiffStatus.APPROVED.value:
                approved_diffs.append(Diff.from_dict(diff_data))

        if not approved_diffs:
            return None

        # Return most recent
        approved_diffs.sort(key=lambda d: d.created_at, reverse=True)
        return approved_diffs[0]

    def list_diffs(
        self,
        status: DiffStatus | None = None,
    ) -> list[Diff]:
        """List all diffs, optionally filtered by status.

        Args:
            status: Optional status to filter by.

        Returns:
            List of diffs.
        """
        index = self._load_index()
        diffs: list[Diff] = []

        for diff_data in index.values():
            diff = Diff.from_dict(diff_data)
            if status is None or diff.status == status:
                diffs.append(diff)

        diffs.sort(key=lambda d: d.created_at, reverse=True)
        return diffs
